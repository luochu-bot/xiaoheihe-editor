<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>å°é»‘ç›’æ–‡ç« è½¬æ¢å™¨ - Markdown è½¬å¯Œæ–‡æœ¬</title>
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      margin: 0;
      padding: 16px;
      background: #f5f5f5;
      line-height: 1.6;
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    /* Column Toggles - Premium Segmented Control */
    .column-toggles {
      display: inline-flex;
      background: #e4e4e7;
      padding: 2px;
      border-radius: 8px;
      gap: 2px;
    }

    .column-toggle {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 500;
      color: #71717a;
      cursor: pointer;
      border-radius: 6px;
      transition: all 0.2s;
      user-select: none;
    }

    .column-toggle:hover {
      color: #27272a;
    }

    .column-toggle input {
      position: absolute;
      opacity: 0;
      cursor: pointer;
      height: 0;
      width: 0;
    }

    .column-toggle:has(input:checked) {
      background: white;
      color: #18181b;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    header {
      flex-shrink: 0;
      margin-bottom: 12px;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
    }

    h1 {
      color: #333;
      margin: 0 0 4px 0;
      font-size: 20px;
    }

    .description {
      color: #666;
      font-size: 13px;
      margin: 0;
    }

    .help-btn {
      padding: 8px 16px;
      background: #fafafa;
      border: 1px solid #e0e0e0;
      border-radius: 6px;
      font-size: 13px;
      color: #555;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
      transition: all 0.2s;
    }

    .help-btn:hover {
      background: #f0f0f0;
      border-color: #ccc;
    }

    .help-btn::before {
      content: "?";
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 16px;
      height: 16px;
      background: #999;
      color: white;
      border-radius: 50%;
      font-size: 11px;
      font-weight: bold;
    }

    /* å¼¹çª—å®¹å™¨ */
    .modal-overlay {
      display: none;
      position: absolute;
      top: 48px;
      right: 16px;
      z-index: 1000;
    }

    .modal-overlay.active {
      display: block;
    }

    /* å¼¹çª— */
    .modal {
      background: white;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
      width: 320px;
      overflow: hidden;
      border: 1px solid #e0e0e0;
    }

    .modal-header {
      padding: 14px 16px;
      background: #fafafa;
      border-bottom: 1px solid #e0e0e0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .modal-title {
      font-size: 14px;
      font-weight: 500;
      color: #333;
    }

    .modal-close {
      width: 24px;
      height: 24px;
      border: none;
      background: transparent;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      color: #999;
      font-size: 18px;
      line-height: 1;
      padding: 0;
    }

    .modal-close:hover {
      background: #e0e0e0;
      color: #666;
    }

    .modal-body {
      padding: 12px 16px;
    }

    .syntax-list {
      list-style: none;
      margin: 0;
      padding: 0;
    }

    .syntax-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 0;
      border-bottom: 1px solid #f0f0f0;
    }

    .syntax-item:last-child {
      border-bottom: none;
    }

    .syntax-icon {
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #666;
      font-size: 14px;
      flex-shrink: 0;
    }

    .syntax-name {
      flex: 1;
      font-size: 13px;
      color: #333;
    }

    .syntax-code {
      font-family: "SF Mono", Monaco, "Cascadia Code", Consolas, monospace;
      font-size: 12px;
      color: #666;
      background: #f5f5f5;
      padding: 4px 8px;
      border-radius: 4px;
    }

    /* Status Bar */
    .status-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0 16px;
      background: #fafafa;
      border-top: 1px solid #e0e0e0;
      font-size: 13px;
      color: #444;
      height: 32px;
      flex-shrink: 0;
    }

    .status-item {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .save-status {
      display: flex;
      align-items: center;
      gap: 4px;
      color: #999;
    }

    .save-status.active {
      color: #4caf50;
    }

    /* Action Buttons in Header */
    .header-actions {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .action-btn {
      padding: 8px 16px;
      background: white;
      border: 1px solid #e0e0e0;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 500;
      color: #555;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: all 0.2s;
    }

    .action-btn:hover {
      background: #f5f5f5;
      border-color: #ccc;
    }

    .action-btn.danger:hover {
      color: #f44336;
      border-color: #f44336;
      background: #fff8f8;
    }

    .action-btn.active {
      background: #e6f0ff;
      border-color: #0066cc;
      color: #0066cc;
    }

    /* Mobile Mode Simulation - Only targets the Export Pane */
    #pane-export.mobile-mode {
      background: #f0f2f5;
    }

    #pane-export.mobile-mode .editor-container {
      max-width: 375px;
      margin: 0 auto;
      background: white;
      border-left: 1px solid #ddd;
      border-right: 1px solid #ddd;
      box-shadow: 0 0 30px rgba(0, 0, 0, 0.1);
    }

    #pane-export.mobile-mode .export-footer {
      max-width: 375px;
      margin: 0 auto;
      background: #fafafa;
    }

    .editor-wrapper {
      flex: 1;
      display: flex;
      gap: 12px;
      min-height: 0;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }

    .editor-pane {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-width: 0;
      overflow: hidden;
      border-right: 1px solid #e0e0e0;
    }

    .editor-pane:last-child {
      border-right: none;
    }

    .editor-pane[hidden] {
      display: none !important;
    }

    .pane-header {
      padding: 0 16px;
      background: #fafafa;
      border-bottom: 1px solid #e0e0e0;
      font-size: 14px;
      font-weight: 600;
      color: #333;
      display: flex;
      align-items: center;
      justify-content: space-between;
      height: 48px;
      flex-shrink: 0;
    }

    .pane-title {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .pane-title::before {
      content: "";
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #4caf50;
    }

    .editor-container {
      flex: 1;
      position: relative;
      overflow: hidden;
    }

    /* Markdown æ–‡æœ¬æ¡†æ ·å¼ */
    .editor-container textarea {
      width: 100%;
      height: 100%;
      padding: 16px;
      border: none;
      outline: none;
      font-family: "SF Mono", Monaco, "Cascadia Code", "Roboto Mono", Consolas, monospace;
      font-size: 14px;
      line-height: 1.7;
      resize: none;
      background: #fff;
      overflow-y: auto;
    }

    /* ProseMirror ç¼–è¾‘å™¨æ ·å¼ */
    .ProseMirror {
      position: relative;
      height: 100%;
      padding: 16px;
      outline: none;
      overflow-y: auto;
      word-wrap: break-word;
      white-space: pre-wrap;
      white-space: break-spaces;
      -webkit-font-variant-ligatures: none;
      font-variant-ligatures: none;
      font-feature-settings: "liga" 0;
    }

    .ProseMirror p {
      margin: 0 0 1em 0;
    }

    .ProseMirror h1,
    .ProseMirror h2,
    .ProseMirror h3,
    .ProseMirror h4 {
      margin: 1.2em 0 0.5em 0;
      line-height: 1.3;
    }

    .ProseMirror h1 {
      font-size: 1.8em;
    }

    .ProseMirror h2 {
      font-size: 1.5em;
    }

    .ProseMirror h3 {
      font-size: 1.25em;
    }

    .ProseMirror ul,
    .ProseMirror ol {
      padding-left: 2em;
      margin: 0 0 1em 0;
    }

    .ProseMirror blockquote {
      border-left: 3px solid #ddd;
      padding-left: 1em;
      margin: 0 0 1em 0;
      color: #666;
    }

    .ProseMirror pre {
      background: #f4f4f4;
      padding: 1em;
      border-radius: 4px;
      overflow-x: auto;
    }

    .ProseMirror code {
      background: #f4f4f4;
      padding: 0.2em 0.4em;
      border-radius: 3px;
      font-family: monospace;
      font-size: 0.9em;
    }

    .ProseMirror pre code {
      background: none;
      padding: 0;
    }

    .ProseMirror a {
      color: #0066cc;
      text-decoration: none;
    }

    .ProseMirror a:hover {
      text-decoration: underline;
    }

    .ProseMirror hr {
      border: none;
      border-top: 2px solid #ddd;
      margin: 2em 0;
    }

    .ProseMirror img {
      max-width: 100%;
      height: auto;
    }

    .ProseMirror table {
      border-collapse: collapse;
      width: 100%;
      margin: 1em 0;
    }

    .ProseMirror td,
    .ProseMirror th {
      border: 1px solid #ddd;
      padding: 8px 12px;
      text-align: left;
    }

    .ProseMirror th {
      background: #f5f5f5;
    }

    /* ProseMirror èœå•æ ·å¼ */
    .ProseMirror-menubar {
      border-bottom: 1px solid #e0e0e0;
      padding: 5px 10px;
      background: #fafafa;
      flex-shrink: 0;
    }

    .ProseMirror-menubar-wrapper {
      display: flex;
      flex-direction: column;
      height: 100%;
    }

    .ProseMirror-menubar-wrapper>.ProseMirror {
      flex: 1;
      overflow-y: auto;
    }

    .ProseMirror-menubar-wrapper .ProseMirror {
      padding-top: 10px;
    }

    .ProseMirror-menuitem {
      display: inline-block;
      margin-right: 3px;
    }

    .ProseMirror-menuseparator {
      display: inline-block;
      margin: 0 4px;
      border-right: 1px solid #ddd;
      height: 20px;
      vertical-align: middle;
    }

    .ProseMirror-icon {
      display: inline-block;
      padding: 4px 8px;
      cursor: pointer;
      border-radius: 3px;
    }

    .ProseMirror-icon:hover {
      background: #e0e0e0;
    }

    .ProseMirror-icon svg {
      fill: currentColor;
      width: 16px;
      height: 16px;
      vertical-align: middle;
    }

    .ProseMirror-menu-active {
      background: #ddd;
    }

    .ProseMirror-prompt {
      position: absolute;
      background: white;
      padding: 15px;
      border-radius: 6px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      z-index: 100;
    }

    .ProseMirror-prompt input[type="text"] {
      padding: 6px 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      margin-right: 8px;
      width: 250px;
    }

    .ProseMirror-prompt-buttons {
      margin-top: 10px;
      text-align: right;
    }

    .ProseMirror-prompt-buttons button {
      padding: 6px 16px;
      margin-left: 8px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    .ProseMirror-prompt-buttons button[type="submit"] {
      background: #0066cc;
      color: white;
    }

    .ProseMirror-prompt-buttons button[type="button"] {
      background: #e0e0e0;
      color: #333;
    }

    /* é€‰ä¸­æ ·å¼ */
    .ProseMirror-selectednode {
      outline: 2px solid #8cf;
    }

    .ProseMirror ::selection {
      background: #b3d4fc;
    }

    /* GapCursor */
    .ProseMirror-gapcursor {
      display: none;
      pointer-events: none;
      position: absolute;
    }

    .ProseMirror-gapcursor:after {
      content: "";
      display: block;
      position: absolute;
      top: -2px;
      width: 20px;
      border-top: 1px solid black;
      animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
    }

    @keyframes ProseMirror-cursor-blink {
      to {
        visibility: hidden;
      }
    }

    .ProseMirror-focused .ProseMirror-gapcursor {
      display: block;
    }

    /* Drop cursor */
    .ProseMirror-dropcursor {
      background: #666;
      width: 2px;
      pointer-events: none;
    }

    /* Tabs styling */
    .tabs {
      display: flex;
      gap: 4px;
    }

    .tab {
      padding: 4px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      color: #666;
      transition: all 0.2s;
    }

    .tab:hover {
      background: #eee;
      color: #333;
    }

    .tab.active {
      background: #e6f0ff;
      color: #0066cc;
      font-weight: 600;
    }

    .tab-content {
      display: none;
      flex: 1;
      flex-direction: column;
      overflow: hidden;
      height: 100%;
    }

    .tab-content.active {
      display: flex;
    }

    /* å¯¼å‡ºç¼–è¾‘å™¨å®¹å™¨ */
    .export-editor-container {
      flex: 1;
      overflow: hidden;
      background: white;
      position: relative;
    }

    .export-editor-container .ProseMirror {
      height: 100%;
      padding: 16px;
      outline: none;
      overflow-y: auto;
      word-wrap: break-word;
      white-space: pre-wrap;
      font-size: 15px;
      /* Slightly larger for better preview */
      line-height: 1.7;
      color: #2c3e50;
    }

    /* å›¾ç‰‡å ä½ç¬¦æ ·å¼ */
    .image-placeholder-node {
      background: #f5f5f5;
      border: 2px dashed #ccc;
      border-radius: 4px;
      padding: 16px;
      margin: 8px 0;
      text-align: center;
      color: #999;
      font-size: 13px;
    }

    .image-placeholder-node.code-block {
      background: #f4f4f4;
      border-style: solid;
      font-family: monospace;
    }

    .export-footer {
      padding: 12px 16px;
      border-top: 1px solid #e0e0e0;
      background: #fafafa;
    }

    /* å¯¼å‡ºæ“ä½œåŒºåŸŸ */
    .export-actions {
      display: flex;
      align-items: center;
      gap: 16px;
      flex-wrap: wrap;
      margin-bottom: 12px;
    }

    .export-copy-btn {
      padding: 8px 16px;
      background: #0066cc;
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: all 0.2s;
    }

    .export-copy-btn:hover {
      background: #0052a3;
    }

    .export-copy-btn.copied {
      background: #4caf50;
    }

    .copy-icon {
      font-size: 16px;
    }

    .copy-hint {
      font-size: 12px;
      color: #999;
    }

    /* å›¾ç‰‡å¤åˆ¶æç¤º */
    .image-copy-hint {
      margin-top: 12px;
      padding: 12px;
      background: #fffbeb;
      border: 1px solid #fbbf24;
      border-radius: 6px;
      font-size: 13px;
      color: #92400e;
      width: 100%;
    }

    .image-copy-hint strong {
      display: block;
      margin-bottom: 4px;
    }

    /* ç¼–è¾‘å™¨å†…å›¾ç‰‡æ‚¬åœæ•ˆæœ */
    .export-editor-container .ProseMirror img {
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      border: 2px solid transparent;
      display: block;
      /* Ensure it behaves as a block to respect margins */
      margin-bottom: 0;
      /* Remove margin bottom for images */
    }

    /* Paragraphs containing only images should have no margin */
    .export-editor-container .ProseMirror p:has(> img:only-child) {
      margin-bottom: 0;
    }

    /* Fallback for browsers not supporting :has - reduce margin for all paragraphs with images slightly? 
       Actually, standard margin is 1em.
       We can try to target paragraphs with images generally if :has fails, but :has is widely supported in modern browsers now.
    */

    .export-editor-container .ProseMirror img:hover {
      transform: scale(1.02);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      border-color: #0066cc;
    }

    /* Header Links */
    .header-link {
      font-size: 13px;
      color: #666;
      text-decoration: none;
      transition: color 0.2s;
    }

    .header-link:hover {
      color: #0066cc;
      text-decoration: underline;
    }
  </style>
</head>

<body>
  <header
    style="display: grid; grid-template-columns: 1fr auto 1fr; align-items: center; margin-bottom: 12px; gap: 16px;">
    <div style="min-width: 0;">
      <h1
        style="display: flex; align-items: center; gap: 8px; margin-bottom: 2px; font-size: 20px; white-space: nowrap;">
        ğŸ“¦ å°é»‘ç›’æ–‡ç« ç¼–è¾‘å™¨</h1>
      <p class="description" style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">ä¸€é”®å°† Markdown
        è½¬æ¢ä¸ºé€‚åˆå°é»‘ç›’å‘å¸ƒçš„å¯Œæ–‡æœ¬å†…å®¹ï¼Œæ”¯æŒä»£ç é«˜äº®ä¸è¡¨æ ¼è½¬å›¾ã€‚</p>
    </div>

    <div class="column-toggles" style="justify-self: center;">
      <label class="column-toggle">
        <input type="checkbox" id="toggle-source" checked> æºç ç¼–è¾‘
      </label>
      <label class="column-toggle">
        <input type="checkbox" id="toggle-preview" checked> å®æ—¶é¢„è§ˆ
      </label>
      <label class="column-toggle">
        <input type="checkbox" id="toggle-export" checked> å¯¼å‡ºè½¬æ¢
      </label>
    </div>

    <div style="display: flex; align-items: center; justify-self: end; gap: 16px;">
      <span style="font-size: 13px; color: #666;">å°é»‘ç›’ ID: 93365144</span>
      <a href="https://evgo2017.com/project/xiaoheihe-editor" target="_blank" class="header-link">é¡¹ç›®ä¸»é¡µ</a>
      <a href="https://github.com/evgo2017/xiaoheihe-editor" target="_blank" class="header-link">æºç ä»“åº“</a>
      <button class="help-btn" id="helpBtn">è¯­æ³•å¸®åŠ©</button>
    </div>
  </header>

  <!-- è¯­æ³•å¸®åŠ©å¼¹çª— -->
  <div class="modal-overlay" id="modalOverlay">
    <div class="modal">
      <div class="modal-header">
        <span class="modal-title">è¯­æ³•å¸®åŠ©</span>
        <button class="modal-close" id="modalClose">&times;</button>
      </div>
      <div class="modal-body">
        <ul class="syntax-list">
          <li class="syntax-item">
            <span class="syntax-icon"><b>H1</b></span>
            <span class="syntax-name">ä¸€çº§æ ‡é¢˜</span>
            <code class="syntax-code"># + ç©ºæ ¼</code>
          </li>
          <li class="syntax-item">
            <span class="syntax-icon"><b>H2</b></span>
            <span class="syntax-name">äºŒçº§æ ‡é¢˜</span>
            <code class="syntax-code">## + ç©ºæ ¼</code>
          </li>
          <li class="syntax-item">
            <span class="syntax-icon">&ldquo;</span>
            <span class="syntax-name">å¼•ç”¨å—</span>
            <code class="syntax-code">&gt; + ç©ºæ ¼</code>
          </li>
          <li class="syntax-item">
            <span class="syntax-icon">â˜°</span>
            <span class="syntax-name">æœ‰åºåˆ—è¡¨</span>
            <code class="syntax-code">æ•°å­— + . + ç©ºæ ¼</code>
          </li>
          <li class="syntax-item">
            <span class="syntax-icon">â˜°</span>
            <span class="syntax-name">æ— åºåˆ—è¡¨</span>
            <code class="syntax-code">- + ç©ºæ ¼</code>
          </li>
          <li class="syntax-item">
            <span class="syntax-icon"><b>B</b></span>
            <span class="syntax-name">ç²—ä½“</span>
            <code class="syntax-code">**æ–‡å­—** + ç©ºæ ¼</code>
          </li>
        </ul>
        <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #e0e0e0;">
          <div style="font-size: 12px; color: #999; margin-bottom: 8px;">å°é»‘ç›’ä¸“ç”¨è½¬æ¢è§„åˆ™</div>
          <ul class="syntax-list">
            <li class="syntax-item">
              <span class="syntax-icon">âœ¨</span>
              <span class="syntax-name">æ ¼å¼å¹³é“º</span>
              <code class="syntax-code">è¡Œå†…ä»£ç /æ–œä½“/åˆ é™¤çº¿ â†’ **ç²—ä½“**</code>
            </li>
            <li class="syntax-item">
              <span class="syntax-icon">â–¦</span>
              <span class="syntax-name">ä»£ç å—/è¡¨æ ¼</span>
              <code class="syntax-code">è‡ªåŠ¨ç”Ÿæˆé«˜äº®å›¾ç‰‡ (é˜²ä¹±ç )</code>
            </li>
            <li class="syntax-item">
              <span class="syntax-icon">â†—</span>
              <span class="syntax-name">è¶…é“¾æ¥</span>
              <code class="syntax-code">è‡ªåŠ¨æ·»åŠ  title (å°é»‘ç›’è§„èŒƒ)</code>
            </li>
            <li class="syntax-item">
              <span class="syntax-icon">â€œ</span>
              <span class="syntax-name">å¼•å·ä¼˜åŒ–</span>
              <code class="syntax-code">**â€œæ–‡å­—â€** â†’ â€œ**æ–‡å­—**â€</code>
            </li>
            <li class="syntax-item">
              <span class="syntax-icon">ğŸ–¼ï¸</span>
              <span class="syntax-name">å›¾ç‰‡å¤„ç†</span>
              <code class="syntax-code">æœ¬åœ°è·¯å¾„è½¬ä¸ºå ä½ç¬¦</code>
            </li>
            <li class="syntax-item">
              <span class="syntax-icon">ğŸ“‹</span>
              <span class="syntax-name">ä¸€é”®å¤åˆ¶</span>
              <code class="syntax-code">è‡ªåŠ¨æ¸…ç†å›¾ç‰‡ alt (é˜²å¹½çµæ–‡å­—)</code>
            </li>
          </ul>
        </div>
      </div>
    </div>
  </div>

  <div class="editor-wrapper">
    <!-- 1. Markdown æºç  -->
    <div class="editor-pane" id="pane-source">
      <div class="pane-header">
        <div class="pane-title">æºç ç¼–è¾‘</div>
        <div style="display: flex; gap: 8px;">
          <button class="action-btn" id="restoreBtn" title="æ¢å¤ä¸ºé»˜è®¤ç¤ºä¾‹å†…å®¹">ğŸ”„ æ¢å¤ç¤ºä¾‹</button>
          <button class="action-btn danger" id="clearBtn" title="æ¸…ç©ºå…¨éƒ¨æºç å†…å®¹">ğŸ—‘ï¸ æ¸…ç©ºå†…å®¹</button>
        </div>
      </div>
      <div id="markdown-editor" class="editor-container"></div>
    </div>

    <!-- 2. å®æ—¶é¢„è§ˆ -->
    <div class="editor-pane" id="pane-preview">
      <div class="pane-header">
        <div class="pane-title">å®æ—¶é¢„è§ˆ</div>
      </div>
      <div id="wysiwyg-editor" class="editor-container"></div>
    </div>

    <!-- 3. å¯¼å‡ºè½¬æ¢ -->
    <div class="editor-pane" id="pane-export">
      <div class="pane-header">
        <div class="pane-title">å¯¼å‡ºè½¬æ¢</div>
        <button class="action-btn" id="mobileViewBtn" title="é¢„è§ˆåœ¨æ‰‹æœºä¸Šçš„æ’ç‰ˆæ•ˆæœ">ğŸ“± æ¨¡æ‹Ÿæ‰‹æœº</button>
      </div>
      <div class="editor-container" style="display: flex; flex-direction: column;">
        <div id="export-editor" class="export-editor-container"></div>
        <div class="export-footer">
          <div class="export-actions" style="margin-bottom: 8px;">
            <button class="export-copy-btn" id="exportCopyBtn">
              <span class="copy-icon">ğŸ“‹</span> ä¸€é”®å¤åˆ¶æ–‡å­—å†…å®¹
            </button>
          </div>
          <div class="image-copy-hint" style="margin-top: 0; padding: 10px 14px;">
            <strong style="display: block; margin-bottom: 4px;">ğŸš€ æ“ä½œæ­¥éª¤</strong>
            <div style="margin: 0; line-height: 1.8; font-size: 13px; color: #666;">
              â€¢ ç‚¹å‡»æŒ‰é’®å¤åˆ¶æ–‡å­—åç›´æ¥åœ¨å°é»‘ç›’ç²˜è´´å³å¯ã€‚ <br>
              â€¢ ä»£ç å—ä¸è¡¨æ ¼å›¾ç‰‡ï¼Œç‰¹æ®Šæƒ…å†µæ—¶ï¼Œå¯å³é”®å›¾ç‰‡æ‰‹åŠ¨å¤åˆ¶ç²˜è´´ã€‚
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- çŠ¶æ€æ  -->
  <div class="status-bar">
    <div class="status-item">
      <span id="wordCountDisplay">å­—ç¬¦ç»Ÿè®¡: 0</span>
      <span style="color: #ddd;">|</span>
      <span id="lineCountDisplay">è¡Œæ•°: 0</span>
    </div>
    <div class="status-item">
      <div id="saveStatus" class="save-status">
        <span class="save-icon">â˜ï¸</span>
        <span id="saveStatusText">å·²è‡ªåŠ¨ä¿å­˜</span>
      </div>
    </div>
  </div>

  <!-- Import Map -->
  <script type="importmap">
  {
    "imports": {
      "prosemirror-view": "./node_modules/prosemirror-view/dist/index.js",
      "prosemirror-state": "./node_modules/prosemirror-state/dist/index.js",
      "prosemirror-markdown": "./node_modules/prosemirror-markdown/dist/index.js",
      "prosemirror-example-setup": "./node_modules/prosemirror-example-setup/dist/index.js",
      "prosemirror-model": "./node_modules/prosemirror-model/dist/index.js",
      "prosemirror-transform": "./node_modules/prosemirror-transform/dist/index.js",
      "prosemirror-commands": "./node_modules/prosemirror-commands/dist/index.js",
      "prosemirror-keymap": "./node_modules/prosemirror-keymap/dist/index.js",
      "prosemirror-schema-list": "./node_modules/prosemirror-schema-list/dist/index.js",
      "prosemirror-history": "./node_modules/prosemirror-history/dist/index.js",
      "prosemirror-dropcursor": "./node_modules/prosemirror-dropcursor/dist/index.js",
      "prosemirror-gapcursor": "./node_modules/prosemirror-gapcursor/dist/index.js",
      "prosemirror-menu": "./node_modules/prosemirror-menu/dist/index.js",
      "prosemirror-inputrules": "./node_modules/prosemirror-inputrules/dist/index.js",
      "crelt": "./node_modules/crelt/index.js",
      "orderedmap": "./node_modules/orderedmap/dist/index.js",
      "rope-sequence": "./node_modules/rope-sequence/dist/index.js",
      "w3c-keyname": "./node_modules/w3c-keyname/index.js",
      "markdown-it": "./node_modules/markdown-it/index.mjs",
      "entities": "./node_modules/entities/lib/esm/index.js",
      "linkify-it": "./node_modules/linkify-it/index.mjs",
      "mdurl": "./node_modules/mdurl/index.mjs",
      "punycode.js": "./node_modules/punycode.js/punycode.es6.js",
      "uc.micro": "./node_modules/uc.micro/index.mjs"
    }
  }
  </script>

  <script type="module">
    import { EditorView } from 'prosemirror-view';
    import { EditorState } from 'prosemirror-state';
    import { schema, defaultMarkdownParser, defaultMarkdownSerializer } from 'prosemirror-markdown';
    import { exampleSetup } from 'prosemirror-example-setup';

    // é»˜è®¤å†…å®¹
    // é»˜è®¤å†…å®¹
    const defaultContent = `# æ¬¢è¿ä½¿ç”¨å°é»‘ç›’æ–‡ç« è½¬æ¢å™¨

ä½œè€…ï¼šå“„å“„ (å°é»‘ç›’ ID: 93365144)

è¿™æ˜¯ä¸€ä¸ªä¸“ä¸ºå°é»‘ç›’ç¤¾åŒºè®¾è®¡çš„è½¬æ¢å·¥å…·ã€‚åœ¨â€œæºç ç¼–è¾‘â€æ ç¼–å†™å†…å®¹ï¼Œé€šè¿‡â€œå®æ—¶é¢„è§ˆâ€æŸ¥çœ‹æ ·å¼ï¼Œæœ€ç»ˆåœ¨â€œå¯¼å‡ºè½¬æ¢â€æ è·å–å¯ä»¥ç›´æ¥å‘å¸ƒåˆ°å°é»‘ç›’çš„å¯Œæ–‡æœ¬æˆæœã€‚

é¡¹ç›®éƒ¨ç½²ï¼š[evgo2017.com/project/xiaoheihe-editor](https://evgo2017.com/project/xiaoheihe-editor)

é¡¹ç›®ç»´æŠ¤ä¸»é¡µï¼š[evgo2017.com/blog/xiaoheihe-editor](https://evgo2017.com/blog/xiaoheihe-editor)

æºç ä»“åº“ï¼š[github.com/evgo2017/xiaoheihe-editor](https://github.com/evgo2017/xiaoheihe-editor)

## 1. åŸºç¡€æ’ç‰ˆ (Common Formats)

**ç²—ä½“æ–‡å­—**ã€*æ–œä½“æ–‡å­—*ã€~~åˆ é™¤çº¿~~ã€‚
è¡Œå†…ä»£ç  \`console.log('Hello')\` ä¼šåœ¨å¯¼å‡ºæ—¶è‡ªåŠ¨è½¬ä¸ºç²—ä½“ã€‚
[å°é»‘ç›’å®˜ç½‘](https://www.xiaoheihe.cn/)

## 2. åˆ—è¡¨ (Lists)

- æ— åºåˆ—è¡¨é¡¹ 1
- æ— åºåˆ—è¡¨é¡¹ 2
  - åµŒå¥—åˆ—è¡¨

1. æœ‰åºåˆ—è¡¨ 1
2. æœ‰åºåˆ—è¡¨ 2

## 3. å¼•ç”¨ä¸åˆ†å‰²çº¿

> å¼•ç”¨å—ï¼šMarkdown æ˜¯ä¸€ç§è½»é‡çº§æ ‡è®°è¯­è¨€ã€‚

---

## 4. æ ¸å¿ƒåŠŸèƒ½ï¼šè‡ªåŠ¨è½¬åŒ– (Auto Conversion)

æœ¬ç¼–è¾‘å™¨æœ€æœ‰ç‰¹è‰²çš„åŠŸèƒ½æ˜¯**è‡ªåŠ¨å°†ä»£ç å—å’Œè¡¨æ ¼è½¬åŒ–ä¸ºå›¾ç‰‡**ï¼Œä»¥é€‚é…ç§»åŠ¨ç«¯é˜…è¯»å¹¶é˜²æ­¢æ ·å¼ä¹±ç ã€‚

### 4.1 ä»£ç å—è½¬å›¾ç‰‡

ä¸‹æ–¹å±•ç¤ºäº†ä¸€æ®µ JavaScript ä»£ç ï¼Œå®ƒä¼šè¢«è‡ªåŠ¨è¯†åˆ«å¹¶è½¬ä¸ºå¸¦æœ‰è¯­æ³•é«˜äº®ã€è‡ªåŠ¨å®½åº¦çš„å›¾ç‰‡ï¼š

\`\`\`javascript
// å°†ä»£ç å—ç”Ÿæˆå›¾ç‰‡
function generateCodeBlockImage(code, language) {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  // ... æ¸²æŸ“é€»è¾‘
  return canvas.toDataURL('image/png');
}
\`\`\`

### 4.2 è¡¨æ ¼è½¬å›¾ç‰‡ (æ”¯æŒå¤šè¡Œæ¢è¡Œ)

å¤æ‚çš„è¡¨æ ¼ä¹Ÿä¼šåœ¨â€œå¯¼å‡ºè½¬æ¢â€æ ä¸­å˜æˆä¸€å¼ æ•´æ´çš„å›¾ç‰‡ï¼Œä¸”æ”¯æŒå•å…ƒæ ¼å†…è‡ªåŠ¨æ¢è¡Œï¼š

| åŠŸèƒ½åç§° | æŠ€æœ¯å®ç°ç»†èŠ‚ | å¯¼å‡ºé¢„è§ˆæ•ˆæœ |
| :--- | :--- | :--- |
| **è¶…é•¿æ–‡æœ¬æ¢è¡Œ** | è¿™æ˜¯ä¸€ä¸ªè¶…é•¿æ–‡æœ¬æµ‹è¯•ï¼Œç”¨äºæ¼”ç¤ºè¡¨æ ¼å†…éƒ¨å¦‚ä½•æ ¹æ®åˆ—å®½è‡ªåŠ¨è¿›è¡Œæ¢è¡Œæ’ç‰ˆï¼Œç¡®ä¿åœ¨ç§»åŠ¨ç«¯é˜…è¯»æ—¶å†…å®¹å®Œæ•´ä¸æº¢å‡ºã€‚ | ğŸ–¼ï¸ è‡ªåŠ¨æ¢è¡Œé¢„è§ˆ |
| **ä»£ç é«˜äº®** | è‡ªå®šä¹‰ Canvas æ¸²æŸ“å¼•æ“ | ğŸ–¼ï¸ è‡ªåŠ¨è½¬ä¸ºå›¾ç‰‡ |
| **æ ¼å¼å¹³é“º** | æ­£åˆ™è¡¨è¾¾å¼é‡å†™æ‰€æœ‰èŠ‚ç‚¹ | **ç»Ÿä¸€åŠ ç²—æ˜¾ç¤º** |
| **å¼•å·ä¼˜åŒ–** | **â€œæå–å¼•å·å¤–ç½®â€** -> â€œ**æå–å¼•å·å¤–ç½®**â€ | è‡ªåŠ¨ä¼˜åŒ–æ’ç‰ˆ |
| **æœ¬åœ°å›¾ç‰‡** | ![æœ¬åœ°å›¾ç‰‡](assets/example.png) | ç”Ÿæˆè·¯å¾„å ä½ç¬¦ |

## 5. å¯¼å‡ºè¯´æ˜

- **æ ¼å¼å¹³é“º**ï¼šè½¬æ¢åçš„æ‰€æœ‰è¡Œå†…æ ¼å¼ï¼ˆä»£ç ã€æ–œä½“ã€åˆ é™¤çº¿ï¼‰éƒ½ä¼šè¢«å¹³é“ºä¸º**ç²—ä½“**ã€‚
- **å¼•å·å¤–ç½®**ï¼šå¦‚æœä½ åœ¨ç²—ä½“ä¸­ä½¿ç”¨å¼•å·ï¼Œå¦‚ \*\*â€œæµ‹è¯•â€\*\*ï¼Œå®ƒä¼šè‡ªåŠ¨ä¼˜åŒ–ä¸º â€œ\*\*æµ‹è¯•\*\*â€ã€‚
- **æœ¬åœ°å›¾ç‰‡**ï¼šå›¾ç‰‡é“¾æ¥å¦‚æœæ˜¯æœ¬åœ°è·¯å¾„ï¼Œä¼šè‡ªåŠ¨è½¬ä¸ºå ä½ç¬¦æç¤ºï¼Œæ–¹ä¾¿æ‰‹åŠ¨å®šä½æ’å…¥ã€‚

> **ğŸ’¡ å¤åˆ¶å°è´´å£«**
> 
> ç‚¹å‡»æœ€å³ä¾§çš„æŒ‰é’®ä¸€é”®å¤åˆ¶æ–‡å­—å†…å®¹ã€‚é’ˆå¯¹ç”Ÿæˆçš„å›¾ç‰‡ï¼Œè¯·å³é”®ç‚¹å‡»é¢„è§ˆå›¾é€‰æ‹©â€œå¤åˆ¶å›¾ç‰‡â€ï¼Œç„¶ååœ¨å°é»‘ç›’ç¼–è¾‘å™¨ä¸­ç²˜è´´å³å¯ã€‚

å¿«å»è¯•è¯•å§ï¼ğŸš€`;

    // Markdown è§†å›¾
    class MarkdownView {
      constructor(target, content, onChange) {
        this.textarea = document.createElement("textarea");
        this.textarea.value = content;
        this.textarea.spellcheck = false;
        target.appendChild(this.textarea);

        this.onChange = onChange;
        this.debounceTimer = null;

        this.textarea.addEventListener('input', () => {
          clearTimeout(this.debounceTimer);
          this.debounceTimer = setTimeout(() => {
            this.onChange(this.textarea.value);
          }, 300);
        });
      }

      get content() {
        return this.textarea.value;
      }

      setContent(content) {
        if (this.textarea.value !== content) {
          const start = this.textarea.selectionStart;
          const end = this.textarea.selectionEnd;
          this.textarea.value = content;
          this.textarea.setSelectionRange(start, end);
        }
      }

      focus() {
        this.textarea.focus();
      }

      destroy() {
        this.textarea.remove();
      }
    }

    // ProseMirror è§†å›¾ - åªè¯»é¢„è§ˆ
    class ProseMirrorView {
      constructor(target, content) {
        let doc;
        try {
          doc = defaultMarkdownParser.parse(content);
        } catch (e) {
          console.warn('Markdown è§£æå¤±è´¥:', e);
        }
        if (!doc) {
          doc = schema.node("doc", null, [schema.node("paragraph")]);
        }

        this.view = new EditorView(target, {
          state: EditorState.create({
            doc: doc,
            plugins: exampleSetup({ schema, menuBar: false })
          }),
          editable: () => false // Read only
        });
      }

      setContent(content) {
        let newDoc;
        try {
          newDoc = defaultMarkdownParser.parse(content);
        } catch (e) {
          console.warn('Markdown è§£æå¤±è´¥:', e);
        }
        if (newDoc) {
          const tr = this.view.state.tr.replaceWith(0, this.view.state.doc.content.size, newDoc.content);
          this.view.dispatch(tr);
        }
      }

      destroy() {
        this.view.destroy();
      }
    }

    // è¯­æ³•å¸®åŠ©å¼¹çª—
    const helpBtn = document.getElementById('helpBtn');
    const modalOverlay = document.getElementById('modalOverlay');
    const modalClose = document.getElementById('modalClose');

    helpBtn.addEventListener('click', () => {
      modalOverlay.classList.add('active');
    });

    modalClose.addEventListener('click', () => {
      modalOverlay.classList.remove('active');
    });

    // å¯¼å‡ºé¢„è§ˆ
    const exportEditorTarget = document.getElementById('export-editor');

    // å°†ä»£ç å—ç”Ÿæˆå›¾ç‰‡
    // Helper for Code Highlighting
    function drawHighlightedCode(ctx, text, x, y) {
      // Expanded keyword list for C++, Python, JS, etc.
      const tokenRegex = /(\/\/.*$|#.*$)|('(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*`)|(\b(?:function|return|if|else|for|while|const|let|var|async|await|import|export|class|new|this|try|catch|true|false|null|undefined|void|typeof|instanceof|public|private|protected|static|virtual|override|int|float|double|char|string|bool|list|dict|set|def|elif|lambda|none|using|namespace|include|template)\b)|(\b\d+\b)/;

      let cursorX = x;
      let remaining = text;

      while (remaining.length > 0) {
        const match = remaining.match(tokenRegex);
        if (!match) {
          ctx.fillStyle = '#333';
          ctx.fillText(remaining, cursorX, y);
          break;
        }

        const index = match.index;
        if (index > 0) {
          const pre = remaining.substring(0, index);
          ctx.fillStyle = '#333';
          ctx.fillText(pre, cursorX, y);
          cursorX += ctx.measureText(pre).width;
        }

        const token = match[0];
        const tokenIndex = match.index;

        if (match[1]) ctx.fillStyle = '#a0a1a7'; // Comment
        else if (match[2]) ctx.fillStyle = '#50a14f'; // String
        else if (match[3]) ctx.fillStyle = '#a626a4'; // Keyword
        else if (match[4]) ctx.fillStyle = '#986801'; // Number
        else ctx.fillStyle = '#333';

        ctx.fillText(token, cursorX, y);
        cursorX += ctx.measureText(token).width;

        remaining = remaining.substring(index + token.length);
      }
    }

    function generateCodeBlockImage(code, language) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');

      const padding = 16;
      const lineHeight = 20;
      const lines = code.split('\n');

      // Calculate required width based on content
      ctx.font = '14px "SF Mono", Monaco, Consolas, monospace';
      let maxLineWidth = 0;
      lines.forEach(line => {
        const metrics = ctx.measureText(line);
        if (metrics.width > maxLineWidth) {
          maxLineWidth = metrics.width;
        }
      });

      const maxWidth = Math.max(600, maxLineWidth + padding * 2 + 20);
      // No truncation for lines or width now, as requested.
      const height = padding * 2 + (language ? 30 : 0) + lines.length * lineHeight;

      canvas.width = maxWidth;
      canvas.height = height;

      // èƒŒæ™¯
      ctx.fillStyle = '#f5f5f5';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // è¾¹æ¡†
      ctx.strokeStyle = '#e0e0e0';
      ctx.lineWidth = 1;
      ctx.strokeRect(0, 0, canvas.width, canvas.height);

      // è¯­è¨€æ ‡ç­¾
      if (language) {
        ctx.fillStyle = '#e0e0e0';
        ctx.fillRect(0, 0, canvas.width, 24);
        ctx.fillStyle = '#666';
        ctx.font = '12px -apple-system, sans-serif';
        ctx.textAlign = 'right';
        ctx.fillText(language, canvas.width - 10, 16);
        ctx.textAlign = 'left';
      }

      // ä»£ç å†…å®¹
      ctx.fillStyle = '#333';
      ctx.font = '14px "SF Mono", Monaco, Consolas, monospace';
      const startY = padding + (language ? 30 : 0);

      lines.forEach((line, index) => {
        drawHighlightedCode(ctx, line, padding, startY + index * lineHeight + 14);
      });

      return canvas.toDataURL('image/png');
    }

    // Helper: Parse rich text into wrapped lines
    function getWrappedLines(ctx, text, maxWidth) {
      // Split by markdown syntax
      const parts = text.split(/(`[^`]+`|\*\*[^*]+\*\*|~~[^~]+~~|__[^_]+__)/g);
      const baseFont = '13px -apple-system, sans-serif';
      const boldFont = 'bold 13px -apple-system, sans-serif';

      let lines = [];
      let currentLine = []; // Array of {text, font}
      let currentLineWidth = 0;

      parts.forEach(part => {
        let isBold = false;
        let content = part;

        if (part.startsWith('`') && part.endsWith('`')) {
          isBold = true; content = part.slice(1, -1);
        } else if (part.startsWith('**') && part.endsWith('**')) {
          isBold = true; content = part.slice(2, -2);
        } else if (part.startsWith('~~') && part.endsWith('~~')) {
          isBold = true; content = part.slice(2, -2);
        } else if (part.startsWith('__') && part.endsWith('__')) {
          isBold = true; content = part.slice(2, -2);
        }

        const font = isBold ? boldFont : baseFont;
        ctx.font = font;

        // Character-level wrapping for robustness with CJK
        for (let i = 0; i < content.length; i++) {
          const char = content[i];
          const charWidth = ctx.measureText(char).width;

          if (currentLineWidth + charWidth > maxWidth) {
            lines.push(currentLine);
            currentLine = [{ text: char, font: font }];
            currentLineWidth = charWidth;
          } else {
            if (currentLine.length > 0 && currentLine[currentLine.length - 1].font === font) {
              currentLine[currentLine.length - 1].text += char;
            } else {
              currentLine.push({ text: char, font: font });
            }
            currentLineWidth += charWidth;
          }
        }
      });

      if (currentLine.length > 0) lines.push(currentLine);
      if (lines.length === 0) lines.push([]);

      return lines;
    }

    // å°†è¡¨æ ¼ç”Ÿæˆå›¾ç‰‡
    function generateTableImage(tableData) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');

      const padding = 12;
      const cellPadding = 10;
      const baseRowHeight = 36;
      const lineHeight = 20;
      const maxWidth = 560;

      // è®¡ç®—åˆ—å®½
      const colCount = tableData[0].length;
      const colWidth = Math.floor((maxWidth - padding * 2) / colCount);
      const cellContentWidth = colWidth - cellPadding * 2;

      // 1. Calculate height for each row
      const processedRows = [];
      let totalHeight = padding * 2;

      tableData.forEach((row, rowIndex) => {
        let maxLinesInRow = 1;
        const rowCells = [];

        row.forEach(cellText => {
          const lines = getWrappedLines(ctx, cellText, cellContentWidth);
          rowCells.push(lines);
          if (lines.length > maxLinesInRow) {
            maxLinesInRow = lines.length;
          }
        });

        const rowContentHeight = maxLinesInRow * lineHeight;
        const rowTotalHeight = Math.max(baseRowHeight, rowContentHeight + 16); // padding top/bottom

        processedRows.push({
          height: rowTotalHeight,
          cells: rowCells
        });

        totalHeight += rowTotalHeight;
      });

      canvas.width = maxWidth;
      canvas.height = totalHeight;

      // èƒŒæ™¯
      ctx.fillStyle = '#fff';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      let currentY = padding;

      processedRows.forEach((rowInfo, rowIndex) => {
        const rowHeight = rowInfo.height;
        const y = currentY;

        // è¡¨å¤´èƒŒæ™¯
        if (rowIndex === 0) {
          ctx.fillStyle = '#f5f5f5';
          ctx.fillRect(padding, y, colCount * colWidth, rowHeight);
        }

        // è¡Œåˆ†éš”çº¿
        ctx.strokeStyle = '#e0e0e0';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(padding, y + rowHeight);
        ctx.lineTo(padding + colCount * colWidth, y + rowHeight);
        ctx.stroke();

        // åˆ—åˆ†éš”çº¿å’Œå†…å®¹
        rowInfo.cells.forEach((lines, colIndex) => {
          const x = padding + colIndex * colWidth;

          // Draw grid line (except for the very first left border which is handled by loop logic or outer border)
          // To be consistent with previous look:
          if (colIndex < colCount) {
            ctx.strokeStyle = '#e0e0e0';
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x, y + rowHeight);
            ctx.stroke();
          }

          // å•å…ƒæ ¼å†…å®¹
          ctx.fillStyle = '#333';
          ctx.textBaseline = 'middle';

          const textBlockHeight = lines.length * lineHeight;
          const startY = y + (rowHeight - textBlockHeight) / 2 + lineHeight / 2;

          lines.forEach((line, lineIndex) => {
            const lineY = startY + lineIndex * lineHeight;
            let currentX = x + cellPadding;

            line.forEach(segment => {
              ctx.font = segment.font;
              ctx.fillText(segment.text, currentX, lineY);
              currentX += ctx.measureText(segment.text).width;
            });
          });
        });

        // å³è¾¹æ¡†
        ctx.beginPath();
        ctx.moveTo(padding + colCount * colWidth, y);
        ctx.lineTo(padding + colCount * colWidth, y + rowHeight);
        ctx.stroke();

        currentY += rowHeight;
      });

      // é¡¶éƒ¨è¾¹æ¡†
      ctx.beginPath();
      ctx.moveTo(padding, padding);
      ctx.lineTo(padding + colCount * colWidth, padding);
      ctx.stroke();

      return canvas.toDataURL('image/png');
    }

    // è§£æè¡¨æ ¼
    function parseTable(markdown) {
      const lines = markdown.trim().split('\n');
      const tableData = [];

      lines.forEach((line, index) => {
        // Robust check for separator lines
        if (/^[\s|:-]+$/.test(line)) return;

        const content = line.trim().replace(/^\||\|$/g, '');
        const cells = content.split('|').map(c => c.trim());

        if (cells.length > 0) {
          tableData.push(cells);
        }
      });

      return tableData;
    }

    // å¤„ç† Markdown å†…å®¹ï¼Œç”Ÿæˆå›¾ç‰‡å¹¶è¿”å›æ–°çš„ Markdown
    async function processMarkdownForExport(markdown) {
      let processed = markdown;

      // 1. å¤„ç†ä»£ç å—
      const codeBlockRegex = /```(\w+)?\n([\s\S]*?)```/g;
      let match;
      while ((match = codeBlockRegex.exec(markdown)) !== null) {
        const language = match[1] || '';
        const code = match[2].trim();
        const imageUrl = generateCodeBlockImage(code, language);
        // Add specific alt text to identify these images later
        processed = processed.replace(match[0], `\n![ä»£ç å—](${imageUrl})\n`);
      }

      // 2. å¤„ç†è¡¨æ ¼
      const tableRegex = /\|[^\n]+\|[^\n]*(?:\n\|[-:]+[-|:]*\|[^\n]*)?(?:\n\|[^\n]+\|[^\n]*)*/g;
      const tables = markdown.match(tableRegex) || [];
      tables.forEach(tableMarkdown => {
        const tableData = parseTable(tableMarkdown);
        if (tableData.length > 0) {
          const imageUrl = generateTableImage(tableData);
          processed = processed.replace(tableMarkdown, `\n![è¡¨æ ¼](${imageUrl})\n`);
        }
      });

      // 2.5 å¤„ç†æœ¬åœ°å›¾ç‰‡ï¼šå°† ![img](assets/...) ç­‰é http/data å›¾ç‰‡è½¬ä¸ºå ä½ç¬¦æ–‡æœ¬
      // This is helpful for manual insertion in target editor
      processed = processed.replace(/!\[(.*?)\]\((?!http|data:)(.*?)\)/g, (match, alt, url) => {
        return `\nï¼ˆå›¾ç‰‡ï¼š${url}ï¼‰\n`;
      });

      // 3. æ ¼å¼å¹³é“ºï¼šå°†è¡Œå†…ä»£ç ã€åˆ é™¤çº¿ã€æ–œä½“éƒ½è½¬æ¢ä¸º **ç²—ä½“**

      // 3.0 Special formatting: **â€œtextâ€** -> â€œ**text**â€ (Pull quotes out of bold)
      // Supports both Chinese quotes â€œ â€ and English quotes " "
      processed = processed.replace(/\*\*â€œ([^â€]+)â€\*\*/g, 'â€œ**$1**â€');
      processed = processed.replace(/\*\*"([^"]+)"\*\*/g, '"**$1**"');

      // 3.1 è¡Œå†…ä»£ç  `code` -> **code**
      // Remove spaces around content if any, to ensure **bold** syntax works
      processed = processed.replace(/`\s*([^`\n]+?)\s*`/g, '**$1**');

      // 3.2 åˆ é™¤çº¿ ~~text~~ -> **text**
      processed = processed.replace(/~~([^~]+?)~~/g, '**$1**');

      // 3.3 æ–œä½“ *text* -> **text** (Handle * and _)
      // Note: This is a simple approximation. Nested formatting might be tricky.
      // We try to catch single *, ensuring it's not **
      processed = processed.replace(/(?<!\*)\*([^*]+?)\*(?!\*)/g, '**$1**');
      processed = processed.replace(/(?<!_)_([^_]+?)_(?!_)/g, '**$1**');

      // 4. å°†è¶…é“¾æ¥ [text](url) è½¬ä¸º [text](url "text")
      // Ensure we don't double-add titles. 
      // If the URL part doesn't have a quote, we add the title.
      // Also trim the captured URL.
      processed = processed.replace(/\[([^\]]+)\]\(([^)"]+)\)/g, (match, text, url) => {
        const cleanUrl = url.trim();
        return `[${text}](${cleanUrl} "${text}")`;
      });

      return processed;
    }

    let exportEditorView = null;

    // åˆ›å»ºå¯¼å‡ºç¼–è¾‘å™¨è§†å›¾ï¼ˆåªè¯»ï¼‰
    function createExportEditor(target, content) {
      // å¦‚æœå·²å­˜åœ¨ï¼Œå…ˆé”€æ¯
      if (exportEditorView) {
        exportEditorView.destroy();
      }

      // æ¸…ç©ºç›®æ ‡å®¹å™¨
      target.innerHTML = '';

      // è§£æ Markdown å†…å®¹
      let doc;
      try {
        doc = defaultMarkdownParser.parse(content);
      } catch (e) {
        console.warn('å¯¼å‡ºé¢„è§ˆè§£æå¤±è´¥:', e);
        doc = schema.node("doc", null, [schema.node("paragraph")]);
      }

      // åˆ›å»ºåªè¯»ç¼–è¾‘å™¨
      exportEditorView = new EditorView(target, {
        state: EditorState.create({
          doc: doc,
          plugins: exampleSetup({ schema, menuBar: false })
        }),
        editable: () => false // Read only
      });

      // Post-process DOM: Fix styles and add listeners
      setTimeout(() => {
        const images = target.querySelectorAll('img');
        images.forEach(img => {
          // ... 
          if (img.alt === 'ä»£ç å—' || img.alt === 'è¡¨æ ¼') {
            const parentP = img.closest('p');
            if (parentP) {
              parentP.style.marginBottom = '0';
              parentP.style.lineHeight = '0';
            }
          }
        });

        // Add scroll listener for sync
        if (exportEditorView) {
          exportEditorView.dom.addEventListener('scroll', handleScroll);
        }
      }, 50);

      return exportEditorView;
    }

    // Column toggle logic
    const toggles = {
      source: document.getElementById('toggle-source'),
      preview: document.getElementById('toggle-preview'),
      export: document.getElementById('toggle-export')
    };

    const panes = {
      source: document.getElementById('pane-source'),
      preview: document.getElementById('pane-preview'),
      export: document.getElementById('pane-export')
    };

    // Initial Sync function
    async function updateExportContent() {
      if (!panes.export.hidden) {
        const content = mdView.content;
        const processedContent = await processMarkdownForExport(content);
        createExportEditor(exportEditorTarget, processedContent);
      }
    }

    // Bind toggles
    Object.keys(toggles).forEach(key => {
      toggles[key].addEventListener('change', (e) => {
        const isChecked = e.target.checked;
        panes[key].hidden = !isChecked;

        // Specific logic when showing export pane
        if (key === 'export' && isChecked) {
          updateExportContent();
        }
      });
    });

    // åˆå§‹åŒ–
    const mdTarget = document.querySelector("#markdown-editor");
    const pmTarget = document.querySelector("#wysiwyg-editor");

    // åˆå§‹åŒ–ç¼–è¾‘å™¨å†…å®¹
    const savedContent = localStorage.getItem('xiaoheihe_editor_content');
    const initialContent = savedContent || defaultContent;

    const mdView = new MarkdownView(mdTarget, initialContent, async (content) => {
      // å®æ—¶åŒæ­¥
      pmView.setContent(content);
      if (!panes.export.hidden) {
        updateExportContent();
      }

      // å¤„ç†çŠ¶æ€å˜æ›´
      updateStatusBar(content);
      autoSave(content);
    });

    const pmView = new ProseMirrorView(pmTarget, initialContent);

    // --- åŠŸèƒ½ç»„ä»¶é€»è¾‘ ---

    // 1. è‡ªåŠ¨ä¿å­˜ä¸çŠ¶æ€æ 
    let saveTimeout = null;
    function autoSave(content) {
      const statusText = document.getElementById('saveStatusText');
      const statusIcon = document.querySelector('.save-status');

      statusText.innerText = 'æ­£åœ¨ä¿å­˜...';
      statusIcon.classList.remove('active');

      clearTimeout(saveTimeout);
      saveTimeout = setTimeout(() => {
        localStorage.setItem('xiaoheihe_editor_content', content);
        statusText.innerText = 'å·²è‡ªåŠ¨ä¿å­˜';
        statusIcon.classList.add('active');
      }, 1000);
    }

    function updateStatusBar(content) {
      const wordCount = content.replace(/[\x00-\xff]/g, "m").replace(/m+/g, "m").length;
      // Simple approximation for CJK + English words
      // Actual count: CJK chars + English words
      const charCount = content.length;
      const filteredContent = content.trim();
      const lineCount = filteredContent ? filteredContent.split('\n').length : 0;

      document.getElementById('wordCountDisplay').innerText = `å­—ç¬¦ç»Ÿè®¡: ${charCount}`;
      document.getElementById('lineCountDisplay').innerText = `è¡Œæ•°: ${lineCount}`;
    }

    // åˆå§‹çŠ¶æ€æ›´æ–°
    updateStatusBar(initialContent);

    // 2. æ¸…ç©ºä¸æ¢å¤å†…å®¹
    const clearBtn = document.getElementById('clearBtn');
    clearBtn.addEventListener('click', () => {
      if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰å†…å®¹å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚')) {
        mdView.textarea.value = '';
        mdView.onChange('');
        mdView.textarea.focus();
      }
    });

    const restoreBtn = document.getElementById('restoreBtn');
    restoreBtn.addEventListener('click', () => {
      if (confirm('ç¡®å®šè¦æ¢å¤ä¸ºé»˜è®¤ç¤ºä¾‹å†…å®¹å—ï¼Ÿå½“å‰å·²ç¼–è¾‘çš„å†…å®¹å°†è¢«è¦†ç›–ã€‚')) {
        mdView.textarea.value = defaultContent;
        mdView.onChange(defaultContent);
        mdView.textarea.focus();
      }
    });

    // 3. æ¨¡æ‹Ÿæ‰‹æœºè§†å›¾ (ä»…é™å¯¼å‡ºé¢„è§ˆæ )
    const mobileViewBtn = document.getElementById('mobileViewBtn');
    const exportPane = document.getElementById('pane-export');
    let isMobileMode = false;

    mobileViewBtn.addEventListener('click', () => {
      isMobileMode = !isMobileMode;
      if (isMobileMode) {
        exportPane.classList.add('mobile-mode');
        mobileViewBtn.classList.add('active');
        mobileViewBtn.innerText = 'ğŸ“± é€€å‡ºæ¨¡æ‹Ÿ';
      } else {
        exportPane.classList.remove('mobile-mode');
        mobileViewBtn.classList.remove('active');
        mobileViewBtn.innerText = 'ğŸ“± æ¨¡æ‹Ÿæ‰‹æœº';
      }
    });

    // --- åŒæ­¥æ»šåŠ¨é€»è¾‘ (Synchronized Scrolling) ---
    let isSyncingScroll = false;
    function handleScroll(e) {
      if (isSyncingScroll) return;

      const source = e.target;
      // Calculate scroll percentage
      const percentage = source.scrollTop / (source.scrollHeight - source.clientHeight);
      if (isNaN(percentage)) return;

      isSyncingScroll = true;

      // Identify scrollable targets
      const targets = [
        mdView.textarea,
        pmView.view.dom,
        exportEditorView ? exportEditorView.dom : null
      ].filter(t => t && t !== source);

      targets.forEach(target => {
        const targetMaxScroll = target.scrollHeight - target.clientHeight;
        target.scrollTop = percentage * targetMaxScroll;
      });

      // Unlock after animation frame or small delay to prevent feedback loops
      window.requestAnimationFrame(() => {
        isSyncingScroll = false;
      });
    }

    // ç»‘å®šåˆå§‹é¢æ¿çš„æ»šåŠ¨äº‹ä»¶
    mdView.textarea.addEventListener('scroll', handleScroll);
    pmView.view.dom.addEventListener('scroll', handleScroll);

    // Trigger initial export content generation
    if (!panes.export.hidden) {
      setTimeout(() => {
        updateExportContent();
      }, 0);
    }

    // å¤åˆ¶åˆ°å‰ªè´´æ¿åŠŸèƒ½
    const exportCopyBtn = document.getElementById('exportCopyBtn');

    // å°† base64 å›¾ç‰‡è½¬æ¢ä¸º Blob
    function base64ToBlob(base64) {
      const parts = base64.split(';base64,');
      const contentType = parts[0].split(':')[1];
      const raw = window.atob(parts[1]);
      const rawLength = raw.length;
      const uInt8Array = new Uint8Array(rawLength);
      for (let i = 0; i < rawLength; ++i) {
        uInt8Array[i] = raw.charCodeAt(i);
      }
      return new Blob([uInt8Array], { type: contentType });
    }

    exportCopyBtn.addEventListener('click', async () => {
      if (!exportEditorView) return;

      try {
        // Fallback to Selection-based copy which behaves exactly like manual user selection
        // This is often more reliable for rich text editors than manual ClipboardItem construction

        // 1. Get the export editor DOM
        const editorDOM = exportEditorView.dom;

        // 2. Clone it to a temporary hidden div so we can modify it safely (remove alts) without affecting view
        const tempContainer = document.createElement('div');
        tempContainer.innerHTML = editorDOM.innerHTML;
        tempContainer.style.cssText = `
          position: fixed;
          left: -9999px;
          top: 0;
          opacity: 0;
          pointer-events: none;
          white-space: pre-wrap; /* Preserve formatting */
        `;

        // 3. Cleanup: Remove 'alt' from images in the temp container
        const images = tempContainer.querySelectorAll('img');
        images.forEach(img => {
          img.removeAttribute('alt');
        });

        document.body.appendChild(tempContainer);

        // 4. Select the temporary content
        const range = document.createRange();
        range.selectNodeContents(tempContainer);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        // 5. Execute Copy
        const successful = document.execCommand('copy');

        // 6. Cleanup
        selection.removeAllRanges();
        document.body.removeChild(tempContainer);

        if (successful) {
          // æ˜¾ç¤ºæˆåŠŸçŠ¶æ€
          const originalText = exportCopyBtn.innerHTML;
          exportCopyBtn.innerHTML = '<span class="copy-icon">âœ“</span> å·²å¤åˆ¶';
          exportCopyBtn.classList.add('copied');

          setTimeout(() => {
            exportCopyBtn.innerHTML = originalText;
            exportCopyBtn.classList.remove('copied');
          }, 2000);
        } else {
          throw new Error('execCommand copy failed');
        }

      } catch (err) {

        console.error('å¤åˆ¶å¤±è´¥:', err);

        // é™çº§æ–¹æ¡ˆï¼šä½¿ç”¨ä¼ ç»Ÿé€‰ä¸­å¤åˆ¶
        try {
          const editorDOM = exportEditorView.dom;

          // åˆ›å»ºéšè—å®¹å™¨
          const tempContainer = document.createElement('div');
          tempContainer.innerHTML = editorDOM.innerHTML;
          tempContainer.style.cssText = `
            position: fixed;
            left: -9999px;
            top: 0;
            opacity: 0;
            pointer-events: none;
          `;
          document.body.appendChild(tempContainer);

          // é€‰ä¸­å¹¶å¤åˆ¶
          const range = document.createRange();
          range.selectNodeContents(tempContainer);
          const selection = window.getSelection();
          selection.removeAllRanges();
          selection.addRange(range);

          const successful = document.execCommand('copy');
          selection.removeAllRanges();
          document.body.removeChild(tempContainer);

          if (successful) {
            const originalText = exportCopyBtn.innerHTML;
            exportCopyBtn.innerHTML = '<span class="copy-icon">âœ“</span> å·²å¤åˆ¶';
            exportCopyBtn.classList.add('copied');
            setTimeout(() => {
              exportCopyBtn.innerHTML = originalText;
              exportCopyBtn.classList.remove('copied');
            }, 2000);
          } else {
            throw new Error('Fallback copy failed');
          }
        } catch (fallbackErr) {
          alert('å¤åˆ¶å¤±è´¥ï¼Œè¯·å°è¯•æ‰‹åŠ¨é€‰ä¸­ç¼–è¾‘å™¨å†…å®¹åå¤åˆ¶');
        }
      }
    });
  </script>
</body>

</html>